// Code generated by protoc-gen-go.
// source: github.com/openconfig/reference/rpc/openconfig/openconfig.proto
// DO NOT EDIT!

/*
Package openconfig is a generated protocol buffer package.

Package openconfig defines the gRPC service for getting and setting the
configuration and state data of a network target based on OpenConfig models.

This package and its contents is a work-in-progress.  It is meant as a
example implementation of the OpenConfig RPC reference specification
(available at github.com/openconfig/public/tree/master/release/models/rpc)
but also contains some additional capabilities not included in the base
RPC specification.


It is generated from these files:
	github.com/openconfig/reference/rpc/openconfig/openconfig.proto

It has these top-level messages:
	Notification
	Update
	Path
	Value
	GetModelsRequest
	ModelQuery
	GetModelsResponse
	ModelData
	GetRequest
	GetResponse
	SetRequest
	SetResponse
	UpdateResponse
	Error
	SubscribeRequest
	SubscriptionList
	Subscription
	QOSMarking
	AliasList
	Alias
	PollRequest
	Proxies
	Proxy
	SubscribeResponse
	Heartbeat
	UDPWrapper
*/
package openconfig

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A Type describes what format a Value's data is encoded in.
type Type int32

const (
	Type_JSON  Type = 0
	Type_BYTES Type = 1
	Type_PROTO Type = 2
)

var Type_name = map[int32]string{
	0: "JSON",
	1: "BYTES",
	2: "PROTO",
}
var Type_value = map[string]int32{
	"JSON":  0,
	"BYTES": 1,
	"PROTO": 2,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}
func (Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// SubscriptionMode mode informs the target how notifications should be
// delivered, as they change or coalesced.  When the mode is TARGET_DEFINED the
// target chooses the mode the best suits the value.  When the mode is
// ON_CHANGE, the target must send a notification each time the value changes.
// When the mode is SAMPLE, the target send notifications at some sampling
// interval.
type SubscriptionMode int32

const (
	SubscriptionMode_TARGET_DEFINED SubscriptionMode = 0
	SubscriptionMode_ON_CHANGE      SubscriptionMode = 1
	SubscriptionMode_SAMPLE         SubscriptionMode = 2
)

var SubscriptionMode_name = map[int32]string{
	0: "TARGET_DEFINED",
	1: "ON_CHANGE",
	2: "SAMPLE",
}
var SubscriptionMode_value = map[string]int32{
	"TARGET_DEFINED": 0,
	"ON_CHANGE":      1,
	"SAMPLE":         2,
}

func (x SubscriptionMode) String() string {
	return proto.EnumName(SubscriptionMode_name, int32(x))
}
func (SubscriptionMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Type selects to return only the summary model information or
// the full YANG model as bytes.  The caller is responsible for extracting the
// YANG model from the bytes.
type GetModelsRequest_Type int32

const (
	GetModelsRequest_SUMMARY GetModelsRequest_Type = 0
	GetModelsRequest_DETAIL  GetModelsRequest_Type = 1
)

var GetModelsRequest_Type_name = map[int32]string{
	0: "SUMMARY",
	1: "DETAIL",
}
var GetModelsRequest_Type_value = map[string]int32{
	"SUMMARY": 0,
	"DETAIL":  1,
}

func (x GetModelsRequest_Type) String() string {
	return proto.EnumName(GetModelsRequest_Type_name, int32(x))
}
func (GetModelsRequest_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type ModelData_Type int32

const (
	ModelData_MODULE       ModelData_Type = 0
	ModelData_BUNDLE       ModelData_Type = 1
	ModelData_AUGMENTATION ModelData_Type = 3
	ModelData_DEVIATION    ModelData_Type = 4
)

var ModelData_Type_name = map[int32]string{
	0: "MODULE",
	1: "BUNDLE",
	3: "AUGMENTATION",
	4: "DEVIATION",
}
var ModelData_Type_value = map[string]int32{
	"MODULE":       0,
	"BUNDLE":       1,
	"AUGMENTATION": 3,
	"DEVIATION":    4,
}

func (x ModelData_Type) String() string {
	return proto.EnumName(ModelData_Type_name, int32(x))
}
func (ModelData_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

// Type defines the mode that Get should use (GET_TYPE in the
// RPC specification YANG schema).
type GetRequest_Type int32

const (
	GetRequest_ALL         GetRequest_Type = 0
	GetRequest_CONFIG      GetRequest_Type = 1
	GetRequest_STATE       GetRequest_Type = 2
	GetRequest_OPERATIONAL GetRequest_Type = 3
)

var GetRequest_Type_name = map[int32]string{
	0: "ALL",
	1: "CONFIG",
	2: "STATE",
	3: "OPERATIONAL",
}
var GetRequest_Type_value = map[string]int32{
	"ALL":         0,
	"CONFIG":      1,
	"STATE":       2,
	"OPERATIONAL": 3,
}

func (x GetRequest_Type) String() string {
	return proto.EnumName(GetRequest_Type_name, int32(x))
}
func (GetRequest_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

type UpdateResponse_Operation int32

const (
	UpdateResponse_NOT_SPECIFIED UpdateResponse_Operation = 0
	UpdateResponse_DELETE        UpdateResponse_Operation = 1
	UpdateResponse_REPLACE       UpdateResponse_Operation = 2
	UpdateResponse_UPDATE        UpdateResponse_Operation = 3
)

var UpdateResponse_Operation_name = map[int32]string{
	0: "NOT_SPECIFIED",
	1: "DELETE",
	2: "REPLACE",
	3: "UPDATE",
}
var UpdateResponse_Operation_value = map[string]int32{
	"NOT_SPECIFIED": 0,
	"DELETE":        1,
	"REPLACE":       2,
	"UPDATE":        3,
}

func (x UpdateResponse_Operation) String() string {
	return proto.EnumName(UpdateResponse_Operation_name, int32(x))
}
func (UpdateResponse_Operation) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

type SubscriptionList_Mode int32

const (
	SubscriptionList_STREAM SubscriptionList_Mode = 0
	SubscriptionList_ONCE   SubscriptionList_Mode = 1
	SubscriptionList_POLL   SubscriptionList_Mode = 2
)

var SubscriptionList_Mode_name = map[int32]string{
	0: "STREAM",
	1: "ONCE",
	2: "POLL",
}
var SubscriptionList_Mode_value = map[string]int32{
	"STREAM": 0,
	"ONCE":   1,
	"POLL":   2,
}

func (x SubscriptionList_Mode) String() string {
	return proto.EnumName(SubscriptionList_Mode_name, int32(x))
}
func (SubscriptionList_Mode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{15, 0} }

// A Notification is a list of updates to apply.  Deletes are a list of paths to
// delete as long as their data is older than timestamp.  Deleting nodes deletes
// all values below the node that are older than timestamp.  Deletes are
// performed after updates are applied.  Delete paths are created by
// concatenating the prefix, if present, with the individual paths.
//
// Timestamps are always represented as nanoseconds since UNIX epoch,
// Jan 1 1970 00:00:00 UTC. Targets which are incapable of generating nanosecond
// resolution are expected to round the timestamp to the highest supported
// resolution.
//
// Update paths are created by concatenating the prefix, if present, with the
// paths contained in the Updates.
//
// It is valid to have a path be in both an update and a delete.  The
// deletion will only delete values that are older than this update.
//
// Each notification should contain at most a single update for a given path.
// If a nonconforming implementation does send multiple updates for a given path
// in a single notification, all but the final update should be ignored.
//
// The prefix should normally be the longest common prefix to all the individual
// update and delete paths.  This reduces the repetition of the common prefix in
// each update and/or delete.  The individual updates and deletes also are a
// Path (repeated list of elements), allowing a notification such as:
//
//   prefix: /a/b/c
//   update: {
//     path: d
//     value: x
//   }
//   update: {
//     path: e/f
//     value: y
//   }
//   update: {
//     path: e/g
//     value: z
//   }
//
// The prefix may begin with an alias.  An alias is a Path with 1 or more
// elements, which maps to another Path.  Aliases may be defined by either the
// target or the client.  Target defined aliases are limited to a single
// element.  Aliases are client specific (though a target may define the same
// alias for multiple clients).
//
// The target defines an alias by sending a Notification that has alias set and
// a non-empty prefix. When alias is set, a Notification need not provide
// updates or deletes.  If the alias was previously defined, it is over ridden
// with the new definition.  Once defined, the target may send the value of
// alias as the first element of a prefix.  A target must not send target
// defined aliases to clients that do not specify the use_aliases option in the
// initial SubscriptionList message.  A target does not need to define aliases
// even if the client does specify the use_aliases option in the initial
// SubscriptionLlist message.
//
// Clients define aliases by sending a SubscriptionRequest with aliases set.
//
// A target should use a defined alias when possible, but is not required to. A
// target may ignore client defined aliases.
//
//
// Clients should not define aliases that are valid paths in the data
// tree.  The target must not define aliases that are valid paths in the
// data tree.
//
// If a target sends a notification with alias set, but not prefix, then it is
// indicating it will no longer use this alias.  The client may delete this
// alias from its list of aliases.  A target may not delete an alias defined by
// the client.  It is implementation dependent on what happens if the client
// defines an alias that is also defined by the target.
//
// Aliases must not be used in UDP packets.
//
// If a client sets the use_aliases option, or defines aliases, in the initial
// SubscriptionList message, then it must always check the initial elements of a
// prefix against the list of known aliases, expanding the prefix as needed.
// Aliases must always be defined as fully expanded prefixes.  Only single alias
// lookup is needed per Notification.
//
// Target defined aliases may be any unique string.  A target may choose to use
// a unique prefix for aliases to make them visually distinct.  For example, a
// target might construct all aliases as an @ character followed by a decimal or
// hexadecimal number (perhaps a hashed address in memory).
//
// Example:
//
// Define @42 as an alias:
//
//   timestamp: 1439416376123456789
//   prefix: "this_is"
//   prefix: "a_long"
//   prefix: "prefix"
//   alias: "@42
//
// Use @42 as an alias to set /this_is/a_long/prefix/Ethernet0/0/1/in-octets to
// 17:
//
//   timestamp: 1439416376456456456
//   prefix: "@42"
//   prefix: "Ethernet0/0/1"
//   update: {
//     path: {
//       element: "in-octets"
//     }
//     value: 17
//   }
//
// Delete the alias @42:
//
//   timestamp: 1439416376987654321
//   alias: @42
type Notification struct {
	Timestamp int64     `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Prefix    *Path     `protobuf:"bytes,2,opt,name=prefix" json:"prefix,omitempty"`
	Alias     string    `protobuf:"bytes,3,opt,name=alias" json:"alias,omitempty"`
	Update    []*Update `protobuf:"bytes,4,rep,name=update" json:"update,omitempty"`
	Delete    []*Path   `protobuf:"bytes,5,rep,name=delete" json:"delete,omitempty"`
}

func (m *Notification) Reset()                    { *m = Notification{} }
func (m *Notification) String() string            { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()               {}
func (*Notification) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Notification) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Notification) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *Notification) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *Notification) GetUpdate() []*Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *Notification) GetDelete() []*Path {
	if m != nil {
		return m.Delete
	}
	return nil
}

// An Update maps a path to a value.
//
// In a Notification, an Update represents a new or updated value for path.  The
// absolute path name is the concatenation of the Notification prefix and the
// Update path.  Updates are only sent by the target.  Path must always specify
// a leaf node.  Value should be a scalar value (e.g., if Value is JSON encoded
// then the value 123 is acceptable, but {"x":123} is not).
//
// In a SetRequest, an Update contains a path to a read-write node and an
// optional value.  The absolute path name is the concatenation of the
// SetRequest prefix and the Update path The path may reference either a
// directory or leaf node.  If value is not present then path, and all its
// subelements, should be removed.  If value set and path references a directory
// node, the value is the JSON encoded tree of values below that node,
// otherwise, if the value is a scalar and may be encoded in JSON are as raw
// BYTES.  the value
//
// For an example of updating a directory node, consider a tree that has the
// following values:
//
//   /a/b/c: 1
//   /a/b/d: 2
//   /a/b/e: 3
//
// And an Update of
//
//   Path: /a/b
//   Value: "{c: 4, f: 5}"
//
// The result is that /a/b/d and /a/b/e are removed, /a/b/c now has the value of
// 4, and /a/b/f is added with the value of 5.
type Update struct {
	Path  *Path  `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Value *Value `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (m *Update) String() string            { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Update) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Update) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// A Path represents an OpenConfig path as a list of strings, one path element
// per string.
type Path struct {
	Element []string `protobuf:"bytes,1,rep,name=element" json:"element,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Path) GetElement() []string {
	if m != nil {
		return m.Element
	}
	return nil
}

// A Value is either raw data or a JSON encoded value.  An enumerated value is
// of type JSON, with the numeric value in the value field and the name of the
// enumerated value in the name field.
type Value struct {
	Value []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Type  Type   `protobuf:"varint,2,opt,name=type,enum=openconfig.Type" json:"type,omitempty"`
	Name  string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Value) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_JSON
}

func (m *Value) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// GetModelsRequest contains a list of models to return.  If no queries are
// specified, all currently support models will be returned.  ModelReturnType
// specifies the format of the model to return.  By default, only summaries will
// be returned.
type GetModelsRequest struct {
	RequestType GetModelsRequest_Type `protobuf:"varint,1,opt,name=request_type,json=requestType,enum=openconfig.GetModelsRequest_Type" json:"request_type,omitempty"`
	Query       *ModelQuery           `protobuf:"bytes,2,opt,name=query" json:"query,omitempty"`
}

func (m *GetModelsRequest) Reset()                    { *m = GetModelsRequest{} }
func (m *GetModelsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetModelsRequest) ProtoMessage()               {}
func (*GetModelsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GetModelsRequest) GetRequestType() GetModelsRequest_Type {
	if m != nil {
		return m.RequestType
	}
	return GetModelsRequest_SUMMARY
}

func (m *GetModelsRequest) GetQuery() *ModelQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// ModelQuery contains a name and/or namespace regex pattern to match against
// supported models on the system.
type ModelQuery struct {
	Name      string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Namespace string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	Version   string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *ModelQuery) Reset()                    { *m = ModelQuery{} }
func (m *ModelQuery) String() string            { return proto.CompactTextString(m) }
func (*ModelQuery) ProtoMessage()               {}
func (*ModelQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ModelQuery) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelQuery) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ModelQuery) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// GetModelsResponse returns a list of models supported by the system.
type GetModelsResponse struct {
	// List of models supported by the system.
	Models []*ModelData `protobuf:"bytes,1,rep,name=models" json:"models,omitempty"`
}

func (m *GetModelsResponse) Reset()                    { *m = GetModelsResponse{} }
func (m *GetModelsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetModelsResponse) ProtoMessage()               {}
func (*GetModelsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetModelsResponse) GetModels() []*ModelData {
	if m != nil {
		return m.Models
	}
	return nil
}

// ModelData contains the summary information for the model as well as the
// actual model data if requested.
type ModelData struct {
	Name      string         `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Namespace string         `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	Version   string         `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
	Data      []byte         `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	ModelType ModelData_Type `protobuf:"varint,5,opt,name=model_type,json=modelType,enum=openconfig.ModelData_Type" json:"model_type,omitempty"`
}

func (m *ModelData) Reset()                    { *m = ModelData{} }
func (m *ModelData) String() string            { return proto.CompactTextString(m) }
func (*ModelData) ProtoMessage()               {}
func (*ModelData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ModelData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelData) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ModelData) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ModelData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ModelData) GetModelType() ModelData_Type {
	if m != nil {
		return m.ModelType
	}
	return ModelData_MODULE
}

// A GetRequest requests all the values identified by path be returns in a
// single GetResponse message.
//
// If cache_interval is provided and is non-zero number of nanoseconds, it is
// a hint of when this get request will be repeated in the future.
type GetRequest struct {
	Prefix        *Path           `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	Path          []*Path         `protobuf:"bytes,2,rep,name=path" json:"path,omitempty"`
	Type          GetRequest_Type `protobuf:"varint,3,opt,name=type,enum=openconfig.GetRequest_Type" json:"type,omitempty"`
	CacheInterval int64           `protobuf:"varint,4,opt,name=cache_interval,json=cacheInterval" json:"cache_interval,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetRequest) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *GetRequest) GetPath() []*Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *GetRequest) GetType() GetRequest_Type {
	if m != nil {
		return m.Type
	}
	return GetRequest_ALL
}

func (m *GetRequest) GetCacheInterval() int64 {
	if m != nil {
		return m.CacheInterval
	}
	return 0
}

type GetResponse struct {
	Notification []*Notification `protobuf:"bytes,1,rep,name=notification" json:"notification,omitempty"`
}

func (m *GetResponse) Reset()                    { *m = GetResponse{} }
func (m *GetResponse) String() string            { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()               {}
func (*GetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *GetResponse) GetNotification() []*Notification {
	if m != nil {
		return m.Notification
	}
	return nil
}

// A SetRequest contains an optional prefix, a list of zero or more Paths to
// delete, a list of zero or more paths to replace, and a list of zero of more
// paths to update.  Deletes should appear to happen first, followed by
// replacements, followed by updates.
//
// If the path lists a node, rather than leaf, the value is presented in JSON.
// When included in replace, it is as if the path was first deleted.  When
// included in update, the value augments the existing value, if any.
//
// The target must either apply all the deletes, replacements, and updates or
// return an error.  The deletes, replacements, and updates should appear to be
// atomically applied.
//
// Non-existing but otherwise valid paths are valid for all operations.  Deletes
// to a non-existing path are a no-op. Updates and replaces to a non-existing
// path will create a path with its values set to values contained in the
// Update.  Any unspecified values will be set to system defaults.
//
// Example:
// A SetRequest consisting of a single replace, which has a Path of "/"
// and a Value of the full current configuration of a target, in JSON, should
// not result in any state changes on the system.
type SetRequest struct {
	Prefix  *Path     `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	Delete  []*Path   `protobuf:"bytes,2,rep,name=delete" json:"delete,omitempty"`
	Replace []*Update `protobuf:"bytes,3,rep,name=replace" json:"replace,omitempty"`
	Update  []*Update `protobuf:"bytes,4,rep,name=update" json:"update,omitempty"`
}

func (m *SetRequest) Reset()                    { *m = SetRequest{} }
func (m *SetRequest) String() string            { return proto.CompactTextString(m) }
func (*SetRequest) ProtoMessage()               {}
func (*SetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *SetRequest) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SetRequest) GetDelete() []*Path {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *SetRequest) GetReplace() []*Update {
	if m != nil {
		return m.Replace
	}
	return nil
}

func (m *SetRequest) GetUpdate() []*Update {
	if m != nil {
		return m.Update
	}
	return nil
}

// A SetResponse contains responses to a SetRequest.  The optional prefix is
// applied to all paths in response.  Each operation and path in a SetRequest
// requires a response.  The target may return additional informational messages
// in the response such as path not found for a delete or update.
type SetResponse struct {
	Prefix   *Path             `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	Response []*UpdateResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *SetResponse) Reset()                    { *m = SetResponse{} }
func (m *SetResponse) String() string            { return proto.CompactTextString(m) }
func (*SetResponse) ProtoMessage()               {}
func (*SetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *SetResponse) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SetResponse) GetResponse() []*UpdateResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// An UpdateResponse contains the response for a single path Update.
type UpdateResponse struct {
	// The timestamp is the time, in nanoseconds since the epoch, that a Set was
	// accepted (i.e., the request was valid).  It does not imply the value was
	// actually propagated to an underlying datastore.
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Path      *Path `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// message contains an informational or an error message.  Required for
	// unsuccessful SetRequest operations.
	Message *Error                   `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	Op      UpdateResponse_Operation `protobuf:"varint,4,opt,name=op,enum=openconfig.UpdateResponse_Operation" json:"op,omitempty"`
}

func (m *UpdateResponse) Reset()                    { *m = UpdateResponse{} }
func (m *UpdateResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateResponse) ProtoMessage()               {}
func (*UpdateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *UpdateResponse) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *UpdateResponse) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *UpdateResponse) GetMessage() *Error {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *UpdateResponse) GetOp() UpdateResponse_Operation {
	if m != nil {
		return m.Op
	}
	return UpdateResponse_NOT_SPECIFIED
}

// An Error contains information about why a particular request failed.
// Examples of informational errors are included in the RPC specification
// YANG modules.
//
// The canonical error codes are defined for each language.
//
//   Go:   import "google.golang.org/grpc/codes"
//   C++:  #include <grpc++/status_code_enum.h>
//   Java: import static io.grpc.Status.Code;
//   C:    #include <grpc/status.h>
//   C#:   using Grpc.Core;
type Error struct {
	Code    uint32               `protobuf:"varint,1,opt,name=code" json:"code,omitempty"`
	Message string               `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	Data    *google_protobuf.Any `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Error) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Error) GetData() *google_protobuf.Any {
	if m != nil {
		return m.Data
	}
	return nil
}

// A SubscribeRequest is either a subscription request, a change to the
// heartbeat rate, initiating a poll, or defining an alias. It is always sent
// from the client to the target.
type SubscribeRequest struct {
	// Types that are valid to be assigned to Request:
	//	*SubscribeRequest_Subscribe
	//	*SubscribeRequest_Heartbeat
	//	*SubscribeRequest_Poll
	//	*SubscribeRequest_Aliases
	Request isSubscribeRequest_Request `protobuf_oneof:"request"`
	Proxy   *Proxies                   `protobuf:"bytes,5,opt,name=proxy" json:"proxy,omitempty"`
}

func (m *SubscribeRequest) Reset()                    { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()               {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type isSubscribeRequest_Request interface {
	isSubscribeRequest_Request()
}

type SubscribeRequest_Subscribe struct {
	Subscribe *SubscriptionList `protobuf:"bytes,1,opt,name=subscribe,oneof"`
}
type SubscribeRequest_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,2,opt,name=heartbeat,oneof"`
}
type SubscribeRequest_Poll struct {
	Poll *PollRequest `protobuf:"bytes,3,opt,name=poll,oneof"`
}
type SubscribeRequest_Aliases struct {
	Aliases *AliasList `protobuf:"bytes,4,opt,name=aliases,oneof"`
}

func (*SubscribeRequest_Subscribe) isSubscribeRequest_Request() {}
func (*SubscribeRequest_Heartbeat) isSubscribeRequest_Request() {}
func (*SubscribeRequest_Poll) isSubscribeRequest_Request()      {}
func (*SubscribeRequest_Aliases) isSubscribeRequest_Request()   {}

func (m *SubscribeRequest) GetRequest() isSubscribeRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SubscribeRequest) GetSubscribe() *SubscriptionList {
	if x, ok := m.GetRequest().(*SubscribeRequest_Subscribe); ok {
		return x.Subscribe
	}
	return nil
}

func (m *SubscribeRequest) GetHeartbeat() *Heartbeat {
	if x, ok := m.GetRequest().(*SubscribeRequest_Heartbeat); ok {
		return x.Heartbeat
	}
	return nil
}

func (m *SubscribeRequest) GetPoll() *PollRequest {
	if x, ok := m.GetRequest().(*SubscribeRequest_Poll); ok {
		return x.Poll
	}
	return nil
}

func (m *SubscribeRequest) GetAliases() *AliasList {
	if x, ok := m.GetRequest().(*SubscribeRequest_Aliases); ok {
		return x.Aliases
	}
	return nil
}

func (m *SubscribeRequest) GetProxy() *Proxies {
	if m != nil {
		return m.Proxy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SubscribeRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SubscribeRequest_OneofMarshaler, _SubscribeRequest_OneofUnmarshaler, _SubscribeRequest_OneofSizer, []interface{}{
		(*SubscribeRequest_Subscribe)(nil),
		(*SubscribeRequest_Heartbeat)(nil),
		(*SubscribeRequest_Poll)(nil),
		(*SubscribeRequest_Aliases)(nil),
	}
}

func _SubscribeRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SubscribeRequest)
	// request
	switch x := m.Request.(type) {
	case *SubscribeRequest_Subscribe:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subscribe); err != nil {
			return err
		}
	case *SubscribeRequest_Heartbeat:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Heartbeat); err != nil {
			return err
		}
	case *SubscribeRequest_Poll:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Poll); err != nil {
			return err
		}
	case *SubscribeRequest_Aliases:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Aliases); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SubscribeRequest.Request has unexpected type %T", x)
	}
	return nil
}

func _SubscribeRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SubscribeRequest)
	switch tag {
	case 1: // request.subscribe
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SubscriptionList)
		err := b.DecodeMessage(msg)
		m.Request = &SubscribeRequest_Subscribe{msg}
		return true, err
	case 2: // request.heartbeat
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Heartbeat)
		err := b.DecodeMessage(msg)
		m.Request = &SubscribeRequest_Heartbeat{msg}
		return true, err
	case 3: // request.poll
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PollRequest)
		err := b.DecodeMessage(msg)
		m.Request = &SubscribeRequest_Poll{msg}
		return true, err
	case 4: // request.aliases
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AliasList)
		err := b.DecodeMessage(msg)
		m.Request = &SubscribeRequest_Aliases{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SubscribeRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SubscribeRequest)
	// request
	switch x := m.Request.(type) {
	case *SubscribeRequest_Subscribe:
		s := proto.Size(x.Subscribe)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeRequest_Heartbeat:
		s := proto.Size(x.Heartbeat)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeRequest_Poll:
		s := proto.Size(x.Poll)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeRequest_Aliases:
		s := proto.Size(x.Aliases)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SubscriptionList contains the list of individual subscriptions.  A
// SubscriptionList is only valid if all of the contained subscriptions are
// valid.
//
// A SubscriptionList operates in one of three modes, all of which operate on
// the streaming channel.
//
// STREAM:  This is the default mode.  The target must send notifications for
// all subscribed values.  After each subscribed value as been sent at least
// once, the target must send a sync_response.  The target continues to send
// update notifications for the subscribed values as indicated in the
// subscription.
//
// ONCE: This mode is used to send a one-time request for data to the target
// by setting once to true in the SubscriptionRequest.  The target sends each
// subscribed value once, followed by a sync_response (indicating all values
// were sent) and then closes the stream.
//
// POLL: This mode provides a method to send periodic requests over a single
// stream similar to conventional polling.  In this mode, the client is able to
// control when data is sent by the target, in contrast to the STREAM mode.
// With a single declared subscription, the target need only parse the
// subscription once, and can expect periodic requests for the corresponding
// data.
//
// After sending a SubscriptionList with mode set to POLL, polls are initiated
// by sending a PollRequest.  The target sends no notifications to the client
// until the first PollRequest is received.  The target responds by sending each
// subscribed value once, followed by a sync_response.  This process repeats
// for subsequent polls.
//
// Polling mode is optional.  If a target does not support the polling mode, it
// must reject a polling subscription request.  If a client sends a new poll
// before the previous poll completes, the target should close the stream with
// an error.
//
// If prefix is set then all subscriptions in the list and all notifications
// generated are relative to prefix.
//
// If qos is provided then marking is the QOS marking to use for this session.
// The target should use this QOS marking, if supported.
//
// In the event of overlapping subscription, the most specific subscription for
// a value is used.  For example, if the following two subscriptions were made:
//
//  /interfaces/interfaces//state
//  /interfaces/interfaces//state/counters
//
// Then values in state outside of counters would be subject to the first
// subscription.  Values inside of counters would be subject to the second
// subscription.
type SubscriptionList struct {
	Prefix       *Path                 `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	Subscription []*Subscription       `protobuf:"bytes,2,rep,name=subscription" json:"subscription,omitempty"`
	UseAliases   bool                  `protobuf:"varint,3,opt,name=use_aliases,json=useAliases" json:"use_aliases,omitempty"`
	Qos          *QOSMarking           `protobuf:"bytes,4,opt,name=qos" json:"qos,omitempty"`
	Mode         SubscriptionList_Mode `protobuf:"varint,5,opt,name=mode,enum=openconfig.SubscriptionList_Mode" json:"mode,omitempty"`
}

func (m *SubscriptionList) Reset()                    { *m = SubscriptionList{} }
func (m *SubscriptionList) String() string            { return proto.CompactTextString(m) }
func (*SubscriptionList) ProtoMessage()               {}
func (*SubscriptionList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *SubscriptionList) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SubscriptionList) GetSubscription() []*Subscription {
	if m != nil {
		return m.Subscription
	}
	return nil
}

func (m *SubscriptionList) GetUseAliases() bool {
	if m != nil {
		return m.UseAliases
	}
	return false
}

func (m *SubscriptionList) GetQos() *QOSMarking {
	if m != nil {
		return m.Qos
	}
	return nil
}

func (m *SubscriptionList) GetMode() SubscriptionList_Mode {
	if m != nil {
		return m.Mode
	}
	return SubscriptionList_STREAM
}

// Subscription contains a path as well as information on how two send
// notifications.
//
// A Subscription contains subscription information for a single path.  The path
// may be either a leaf node or a directory node in the tree.  When subscribing
// for a directory node, all nodes below it are automatically included in the
// subscription.
//
// If mode is ON_CHANGE, then the target must either be able to send
// notifications each time a value changes or reject the subscription.  This is
// typically used for events.  The sample_interval is ignored when the mode in
// ON_CHANGE.
//
// If mode is SAMPLE, the target must coalesce notifications based on the
// provided sample_interval.  This is typically used for aggregating values
// (i.e., counters).  The sample_interval, if not 0, is the number of
// nanoseconds between updates.  If 0, the interval is selected by the target.
// If the target cannot support the supplied sample_interval, the Subscription
// must be rejected.  The sample_interval is only used for subscriptions in
// streaming mode.  The sample_interval is ignored if mode is not SAMPLE.
//
// (Setting mode to SAMPLE and sample_interval to 0 is functionally the
// same as setting mode to TARGET_DEFINED.)
//
// The suppress_redundant field, if true, indicates the target should not send
// notifications for fields that are unchanged since.  This value is ignored
// if mode is not SAMPLE.
//
// The heartbeat_interval field specifies how frequently an unchanged value must
// be sent regardless of the suppress_redundant field.  A value of 0 indicates
// there is no heartbeat_interval and values only need to be sent when changed.
// The target must reject a subscription if it cannot support the requested
// heartbeat_interval.  This value is ignored if mode is not SAMPLE.
type Subscription struct {
	Path              *Path            `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Mode              SubscriptionMode `protobuf:"varint,2,opt,name=mode,enum=openconfig.SubscriptionMode" json:"mode,omitempty"`
	SampleInterval    uint64           `protobuf:"varint,3,opt,name=sample_interval,json=sampleInterval" json:"sample_interval,omitempty"`
	SuppressRedundant bool             `protobuf:"varint,4,opt,name=suppress_redundant,json=suppressRedundant" json:"suppress_redundant,omitempty"`
	HeartbeatInterval uint64           `protobuf:"varint,5,opt,name=heartbeat_interval,json=heartbeatInterval" json:"heartbeat_interval,omitempty"`
}

func (m *Subscription) Reset()                    { *m = Subscription{} }
func (m *Subscription) String() string            { return proto.CompactTextString(m) }
func (*Subscription) ProtoMessage()               {}
func (*Subscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Subscription) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Subscription) GetMode() SubscriptionMode {
	if m != nil {
		return m.Mode
	}
	return SubscriptionMode_TARGET_DEFINED
}

func (m *Subscription) GetSampleInterval() uint64 {
	if m != nil {
		return m.SampleInterval
	}
	return 0
}

func (m *Subscription) GetSuppressRedundant() bool {
	if m != nil {
		return m.SuppressRedundant
	}
	return false
}

func (m *Subscription) GetHeartbeatInterval() uint64 {
	if m != nil {
		return m.HeartbeatInterval
	}
	return 0
}

// A QOSMarking describes the QOS marking to use, if supported by the target.
type QOSMarking struct {
	Marking uint32 `protobuf:"varint,1,opt,name=marking" json:"marking,omitempty"`
}

func (m *QOSMarking) Reset()                    { *m = QOSMarking{} }
func (m *QOSMarking) String() string            { return proto.CompactTextString(m) }
func (*QOSMarking) ProtoMessage()               {}
func (*QOSMarking) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *QOSMarking) GetMarking() uint32 {
	if m != nil {
		return m.Marking
	}
	return 0
}

// An AliasList represents a list of aliases.
type AliasList struct {
	Alias []*Alias `protobuf:"bytes,1,rep,name=alias" json:"alias,omitempty"`
}

func (m *AliasList) Reset()                    { *m = AliasList{} }
func (m *AliasList) String() string            { return proto.CompactTextString(m) }
func (*AliasList) ProtoMessage()               {}
func (*AliasList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *AliasList) GetAlias() []*Alias {
	if m != nil {
		return m.Alias
	}
	return nil
}

// An Alias specifies a preferred client defined alias for a specified path.  An
// Alias is only sent from the client to the target.  An alias is typically one
// element and is much shorter than the provided path.  A target should
// substitute alias for path in Notifications.  Targets may ignore Alias
// messages.
//
// The path must be fully expanded and not use an alias.
//
// If alias is set and path is not then the alias must no longer be used by the
// target, once received.  A client may still see Notifications using the alias
// that were generated prior to the target receiving the request to stop using
// the alias.
type Alias struct {
	Path  *Path `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Alias *Path `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
}

func (m *Alias) Reset()                    { *m = Alias{} }
func (m *Alias) String() string            { return proto.CompactTextString(m) }
func (*Alias) ProtoMessage()               {}
func (*Alias) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Alias) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Alias) GetAlias() *Path {
	if m != nil {
		return m.Alias
	}
	return nil
}

// A PollRequest requests that all values in the subscription be resent.
type PollRequest struct {
}

func (m *PollRequest) Reset()                    { *m = PollRequest{} }
func (m *PollRequest) String() string            { return proto.CompactTextString(m) }
func (*PollRequest) ProtoMessage()               {}
func (*PollRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

// Proxies is a list of proxies to use to get to the target.  The first proxy
// listed is the the next hop.  Actual targets ignore the proxy field (it should
// not be set when the request reaches the target).
//
// The target_name is an optional informational field describing the ultimate
// destination of the subscribe request.  Proxies may find it useful to use this
// information in logs and errors.
//
// The client_name is an optional informational field describing the client
// making the subscribe request.  Proxies may find it useful to use this
// information in logs and errors.
type Proxies struct {
	Proxy      []*Proxy `protobuf:"bytes,1,rep,name=proxy" json:"proxy,omitempty"`
	TargetName string   `protobuf:"bytes,2,opt,name=target_name,json=targetName" json:"target_name,omitempty"`
	ClientName string   `protobuf:"bytes,3,opt,name=client_name,json=clientName" json:"client_name,omitempty"`
}

func (m *Proxies) Reset()                    { *m = Proxies{} }
func (m *Proxies) String() string            { return proto.CompactTextString(m) }
func (*Proxies) ProtoMessage()               {}
func (*Proxies) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *Proxies) GetProxy() []*Proxy {
	if m != nil {
		return m.Proxy
	}
	return nil
}

func (m *Proxies) GetTargetName() string {
	if m != nil {
		return m.TargetName
	}
	return ""
}

func (m *Proxies) GetClientName() string {
	if m != nil {
		return m.ClientName
	}
	return ""
}

// A Proxy represents a proxy service to use when connecting to the target.
type Proxy struct {
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *Proxy) Reset()                    { *m = Proxy{} }
func (m *Proxy) String() string            { return proto.CompactTextString(m) }
func (*Proxy) ProtoMessage()               {}
func (*Proxy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *Proxy) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Proxy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// A SubscribeResponse is always sent from the target to the client.
//
// Notifications are sent as described above in SubscribeList.
//
// A sync_response is sent when the target finishes sending all the subscribed
// values at least once. sync_response must be set to true for the client to
// consider the stream synced.
type SubscribeResponse struct {
	// Types that are valid to be assigned to Response:
	//	*SubscribeResponse_Update
	//	*SubscribeResponse_Heartbeat
	//	*SubscribeResponse_SyncResponse
	Response isSubscribeResponse_Response `protobuf_oneof:"response"`
}

func (m *SubscribeResponse) Reset()                    { *m = SubscribeResponse{} }
func (m *SubscribeResponse) String() string            { return proto.CompactTextString(m) }
func (*SubscribeResponse) ProtoMessage()               {}
func (*SubscribeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

type isSubscribeResponse_Response interface {
	isSubscribeResponse_Response()
}

type SubscribeResponse_Update struct {
	Update *Notification `protobuf:"bytes,1,opt,name=update,oneof"`
}
type SubscribeResponse_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,2,opt,name=heartbeat,oneof"`
}
type SubscribeResponse_SyncResponse struct {
	SyncResponse bool `protobuf:"varint,3,opt,name=sync_response,json=syncResponse,oneof"`
}

func (*SubscribeResponse_Update) isSubscribeResponse_Response()       {}
func (*SubscribeResponse_Heartbeat) isSubscribeResponse_Response()    {}
func (*SubscribeResponse_SyncResponse) isSubscribeResponse_Response() {}

func (m *SubscribeResponse) GetResponse() isSubscribeResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SubscribeResponse) GetUpdate() *Notification {
	if x, ok := m.GetResponse().(*SubscribeResponse_Update); ok {
		return x.Update
	}
	return nil
}

func (m *SubscribeResponse) GetHeartbeat() *Heartbeat {
	if x, ok := m.GetResponse().(*SubscribeResponse_Heartbeat); ok {
		return x.Heartbeat
	}
	return nil
}

func (m *SubscribeResponse) GetSyncResponse() bool {
	if x, ok := m.GetResponse().(*SubscribeResponse_SyncResponse); ok {
		return x.SyncResponse
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SubscribeResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SubscribeResponse_OneofMarshaler, _SubscribeResponse_OneofUnmarshaler, _SubscribeResponse_OneofSizer, []interface{}{
		(*SubscribeResponse_Update)(nil),
		(*SubscribeResponse_Heartbeat)(nil),
		(*SubscribeResponse_SyncResponse)(nil),
	}
}

func _SubscribeResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SubscribeResponse)
	// response
	switch x := m.Response.(type) {
	case *SubscribeResponse_Update:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Update); err != nil {
			return err
		}
	case *SubscribeResponse_Heartbeat:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Heartbeat); err != nil {
			return err
		}
	case *SubscribeResponse_SyncResponse:
		t := uint64(0)
		if x.SyncResponse {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("SubscribeResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _SubscribeResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SubscribeResponse)
	switch tag {
	case 1: // response.update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Notification)
		err := b.DecodeMessage(msg)
		m.Response = &SubscribeResponse_Update{msg}
		return true, err
	case 2: // response.heartbeat
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Heartbeat)
		err := b.DecodeMessage(msg)
		m.Response = &SubscribeResponse_Heartbeat{msg}
		return true, err
	case 3: // response.sync_response
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Response = &SubscribeResponse_SyncResponse{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _SubscribeResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SubscribeResponse)
	// response
	switch x := m.Response.(type) {
	case *SubscribeResponse_Update:
		s := proto.Size(x.Update)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeResponse_Heartbeat:
		s := proto.Size(x.Heartbeat)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeResponse_SyncResponse:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A Heartbeat requests a (possibly repeated) response from the remote side.
type Heartbeat struct {
	// interval is the maximum amount of time, in nanoseconds, between subsequent
	// messages from the remote side.  An empty message may be sent if no other
	// messages are pending.  If interval is 0 then the remote must immediately
	// respond with a (possibly empty) message.
	Interval uint64 `protobuf:"varint,1,opt,name=interval" json:"interval,omitempty"`
}

func (m *Heartbeat) Reset()                    { *m = Heartbeat{} }
func (m *Heartbeat) String() string            { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()               {}
func (*Heartbeat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *Heartbeat) GetInterval() uint64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

// UDPWrapper adds metadata necessary for encapsulating a list of notifications
// into a UDP packet.  It adds the ability to identify the target that
// originated the Notifications, detect packet loss, and identify latency
// introduced by the target wrapping notifications.
//
// The target should keep the total size of a serialized UDPWrapper message
// small enough to not cause IP packet fragmentation.
type UDPWrapper struct {
	// ID Identifies the target (e.g., Loopback IP address, linecard, ...)
	// TODO(borman): Add examples.  Perhaps agent/module/submodule for vendor.
	Id *Path `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Optional Epoch time of when the message is queued for transmit.
	// Useful to quantify delay between message generation and transmission.
	TransmitTimestamp uint64 `protobuf:"varint,2,opt,name=transmit_timestamp,json=transmitTimestamp" json:"transmit_timestamp,omitempty"`
	// The sequence_number must start at 1 and increment by 1 for each new packet
	// sent.  A client may use this to determine if a packet was lost.
	SequenceNumber uint64          `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber" json:"sequence_number,omitempty"`
	Notification   []*Notification `protobuf:"bytes,4,rep,name=notification" json:"notification,omitempty"`
}

func (m *UDPWrapper) Reset()                    { *m = UDPWrapper{} }
func (m *UDPWrapper) String() string            { return proto.CompactTextString(m) }
func (*UDPWrapper) ProtoMessage()               {}
func (*UDPWrapper) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *UDPWrapper) GetId() *Path {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *UDPWrapper) GetTransmitTimestamp() uint64 {
	if m != nil {
		return m.TransmitTimestamp
	}
	return 0
}

func (m *UDPWrapper) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *UDPWrapper) GetNotification() []*Notification {
	if m != nil {
		return m.Notification
	}
	return nil
}

func init() {
	proto.RegisterType((*Notification)(nil), "openconfig.Notification")
	proto.RegisterType((*Update)(nil), "openconfig.Update")
	proto.RegisterType((*Path)(nil), "openconfig.Path")
	proto.RegisterType((*Value)(nil), "openconfig.Value")
	proto.RegisterType((*GetModelsRequest)(nil), "openconfig.GetModelsRequest")
	proto.RegisterType((*ModelQuery)(nil), "openconfig.ModelQuery")
	proto.RegisterType((*GetModelsResponse)(nil), "openconfig.GetModelsResponse")
	proto.RegisterType((*ModelData)(nil), "openconfig.ModelData")
	proto.RegisterType((*GetRequest)(nil), "openconfig.GetRequest")
	proto.RegisterType((*GetResponse)(nil), "openconfig.GetResponse")
	proto.RegisterType((*SetRequest)(nil), "openconfig.SetRequest")
	proto.RegisterType((*SetResponse)(nil), "openconfig.SetResponse")
	proto.RegisterType((*UpdateResponse)(nil), "openconfig.UpdateResponse")
	proto.RegisterType((*Error)(nil), "openconfig.Error")
	proto.RegisterType((*SubscribeRequest)(nil), "openconfig.SubscribeRequest")
	proto.RegisterType((*SubscriptionList)(nil), "openconfig.SubscriptionList")
	proto.RegisterType((*Subscription)(nil), "openconfig.Subscription")
	proto.RegisterType((*QOSMarking)(nil), "openconfig.QOSMarking")
	proto.RegisterType((*AliasList)(nil), "openconfig.AliasList")
	proto.RegisterType((*Alias)(nil), "openconfig.Alias")
	proto.RegisterType((*PollRequest)(nil), "openconfig.PollRequest")
	proto.RegisterType((*Proxies)(nil), "openconfig.Proxies")
	proto.RegisterType((*Proxy)(nil), "openconfig.Proxy")
	proto.RegisterType((*SubscribeResponse)(nil), "openconfig.SubscribeResponse")
	proto.RegisterType((*Heartbeat)(nil), "openconfig.Heartbeat")
	proto.RegisterType((*UDPWrapper)(nil), "openconfig.UDPWrapper")
	proto.RegisterEnum("openconfig.Type", Type_name, Type_value)
	proto.RegisterEnum("openconfig.SubscriptionMode", SubscriptionMode_name, SubscriptionMode_value)
	proto.RegisterEnum("openconfig.GetModelsRequest_Type", GetModelsRequest_Type_name, GetModelsRequest_Type_value)
	proto.RegisterEnum("openconfig.ModelData_Type", ModelData_Type_name, ModelData_Type_value)
	proto.RegisterEnum("openconfig.GetRequest_Type", GetRequest_Type_name, GetRequest_Type_value)
	proto.RegisterEnum("openconfig.UpdateResponse_Operation", UpdateResponse_Operation_name, UpdateResponse_Operation_value)
	proto.RegisterEnum("openconfig.SubscriptionList_Mode", SubscriptionList_Mode_name, SubscriptionList_Mode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for OpenConfig service

type OpenConfigClient interface {
	// Get requests a single snapshot of specified data.  A Get request may
	// contain a hint that the request will be repeated (i.e., polling).
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// GetModels returns information about the YANG models supported by the
	// target.
	GetModels(ctx context.Context, in *GetModelsRequest, opts ...grpc.CallOption) (*GetModelsResponse, error)
	// Set is the primary function for sending configuration data to the target.
	// It sets the paths contained in the SetRequest to the specified values. If
	// any of the paths are invalid, or are read-only, the SetResponse will
	// return an error. All paths in the SetRequest must be valid or the entire
	// request must be rejected. If a path specifies an internal node, rather than
	// a leaf, then the value must be the values of the node's children encoded
	// in JSON. Binary data in the tree must be base64 encoded, but if a path
	// specifies a leaf of binary type, it may be sent as binary. See SetRequest
	// for further explanation on the atomicity and idempotency of a Set
	// operation.
	Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error)
	// Subscribe subscribes for streaming updates.  Streaming updates are provided
	// as a series of Notifications, each of which update a portion of the tree.
	// The initial SubscribeRequest contains a SubscriptionList, described below.
	Subscribe(ctx context.Context, opts ...grpc.CallOption) (OpenConfig_SubscribeClient, error)
}

type openConfigClient struct {
	cc *grpc.ClientConn
}

func NewOpenConfigClient(cc *grpc.ClientConn) OpenConfigClient {
	return &openConfigClient{cc}
}

func (c *openConfigClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := grpc.Invoke(ctx, "/openconfig.OpenConfig/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openConfigClient) GetModels(ctx context.Context, in *GetModelsRequest, opts ...grpc.CallOption) (*GetModelsResponse, error) {
	out := new(GetModelsResponse)
	err := grpc.Invoke(ctx, "/openconfig.OpenConfig/GetModels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openConfigClient) Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error) {
	out := new(SetResponse)
	err := grpc.Invoke(ctx, "/openconfig.OpenConfig/Set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openConfigClient) Subscribe(ctx context.Context, opts ...grpc.CallOption) (OpenConfig_SubscribeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OpenConfig_serviceDesc.Streams[0], c.cc, "/openconfig.OpenConfig/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &openConfigSubscribeClient{stream}
	return x, nil
}

type OpenConfig_SubscribeClient interface {
	Send(*SubscribeRequest) error
	Recv() (*SubscribeResponse, error)
	grpc.ClientStream
}

type openConfigSubscribeClient struct {
	grpc.ClientStream
}

func (x *openConfigSubscribeClient) Send(m *SubscribeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *openConfigSubscribeClient) Recv() (*SubscribeResponse, error) {
	m := new(SubscribeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for OpenConfig service

type OpenConfigServer interface {
	// Get requests a single snapshot of specified data.  A Get request may
	// contain a hint that the request will be repeated (i.e., polling).
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// GetModels returns information about the YANG models supported by the
	// target.
	GetModels(context.Context, *GetModelsRequest) (*GetModelsResponse, error)
	// Set is the primary function for sending configuration data to the target.
	// It sets the paths contained in the SetRequest to the specified values. If
	// any of the paths are invalid, or are read-only, the SetResponse will
	// return an error. All paths in the SetRequest must be valid or the entire
	// request must be rejected. If a path specifies an internal node, rather than
	// a leaf, then the value must be the values of the node's children encoded
	// in JSON. Binary data in the tree must be base64 encoded, but if a path
	// specifies a leaf of binary type, it may be sent as binary. See SetRequest
	// for further explanation on the atomicity and idempotency of a Set
	// operation.
	Set(context.Context, *SetRequest) (*SetResponse, error)
	// Subscribe subscribes for streaming updates.  Streaming updates are provided
	// as a series of Notifications, each of which update a portion of the tree.
	// The initial SubscribeRequest contains a SubscriptionList, described below.
	Subscribe(OpenConfig_SubscribeServer) error
}

func RegisterOpenConfigServer(s *grpc.Server, srv OpenConfigServer) {
	s.RegisterService(&_OpenConfig_serviceDesc, srv)
}

func _OpenConfig_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenConfigServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openconfig.OpenConfig/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenConfigServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenConfig_GetModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenConfigServer).GetModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openconfig.OpenConfig/GetModels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenConfigServer).GetModels(ctx, req.(*GetModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenConfig_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenConfigServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openconfig.OpenConfig/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenConfigServer).Set(ctx, req.(*SetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenConfig_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OpenConfigServer).Subscribe(&openConfigSubscribeServer{stream})
}

type OpenConfig_SubscribeServer interface {
	Send(*SubscribeResponse) error
	Recv() (*SubscribeRequest, error)
	grpc.ServerStream
}

type openConfigSubscribeServer struct {
	grpc.ServerStream
}

func (x *openConfigSubscribeServer) Send(m *SubscribeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *openConfigSubscribeServer) Recv() (*SubscribeRequest, error) {
	m := new(SubscribeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _OpenConfig_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openconfig.OpenConfig",
	HandlerType: (*OpenConfigServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _OpenConfig_Get_Handler,
		},
		{
			MethodName: "GetModels",
			Handler:    _OpenConfig_GetModels_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _OpenConfig_Set_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _OpenConfig_Subscribe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "github.com/openconfig/reference/rpc/openconfig/openconfig.proto",
}

func init() {
	proto.RegisterFile("github.com/openconfig/reference/rpc/openconfig/openconfig.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1574 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x57, 0x4b, 0x6f, 0x1b, 0x55,
	0x14, 0xee, 0xf8, 0x91, 0x64, 0x8e, 0x93, 0xd4, 0xb9, 0x94, 0x36, 0x0a, 0x45, 0x4d, 0x47, 0x6d,
	0x1a, 0x0a, 0xc4, 0x25, 0xb4, 0x20, 0xa4, 0x4a, 0xd5, 0x24, 0x9e, 0x26, 0x06, 0xbf, 0x7a, 0x6d,
	0xb7, 0x74, 0x65, 0x4d, 0x9c, 0x1b, 0x67, 0x84, 0x3d, 0x33, 0x9d, 0x19, 0x57, 0xcd, 0xff, 0x60,
	0xcf, 0x06, 0x89, 0x35, 0x5b, 0x96, 0x88, 0xff, 0xc2, 0x8a, 0x7f, 0xc0, 0x82, 0x73, 0x1f, 0xf3,
	0x70, 0x62, 0xa7, 0x0f, 0xb1, 0x88, 0x32, 0xf7, 0x3c, 0xee, 0x3d, 0x8f, 0xef, 0x3c, 0x0c, 0x4f,
	0x86, 0x4e, 0x74, 0x3a, 0x39, 0xda, 0x19, 0x78, 0xe3, 0x8a, 0xe7, 0x33, 0x77, 0xe0, 0xb9, 0x27,
	0xce, 0xb0, 0x12, 0xb0, 0x13, 0x16, 0xe0, 0x89, 0x55, 0x02, 0x7f, 0x90, 0x65, 0xa4, 0x9f, 0x3b,
	0x7e, 0xe0, 0x45, 0x1e, 0x81, 0x94, 0xb2, 0x51, 0xc9, 0x5c, 0x36, 0xf4, 0x46, 0xb6, 0x3b, 0xac,
	0x08, 0xa1, 0xa3, 0xc9, 0x49, 0xc5, 0x8f, 0xce, 0x7c, 0x16, 0x56, 0x6c, 0xf7, 0x8c, 0xff, 0x49,
	0x65, 0xe3, 0x4f, 0x0d, 0x96, 0x9b, 0x5e, 0xe4, 0x9c, 0x38, 0x03, 0x3b, 0x72, 0x3c, 0x97, 0xdc,
	0x04, 0x3d, 0x72, 0xc6, 0x2c, 0x8c, 0xec, 0xb1, 0xbf, 0xae, 0x6d, 0x6a, 0xdb, 0x79, 0x9a, 0x12,
	0xc8, 0x36, 0x2c, 0xf8, 0x68, 0x99, 0xf3, 0x66, 0x3d, 0x87, 0xac, 0xd2, 0x6e, 0x79, 0x27, 0x63,
	0x4e, 0xdb, 0x8e, 0x4e, 0xa9, 0xe2, 0x93, 0x6b, 0x50, 0xb4, 0x47, 0x8e, 0x1d, 0xae, 0xe7, 0x51,
	0x50, 0xa7, 0xf2, 0x40, 0xee, 0xc3, 0xc2, 0xc4, 0x3f, 0xb6, 0x23, 0xb6, 0x5e, 0xd8, 0xcc, 0xa3,
	0x3e, 0xc9, 0xea, 0xf7, 0x04, 0x87, 0x2a, 0x09, 0xfe, 0xd6, 0x31, 0x1b, 0x31, 0x94, 0x2d, 0x0a,
	0xd9, 0x19, 0x6f, 0x49, 0xbe, 0xf1, 0x02, 0x16, 0xa4, 0x2e, 0xb9, 0x03, 0x05, 0x1f, 0x39, 0xc2,
	0xf0, 0x59, 0x1a, 0x82, 0x4b, 0xee, 0x41, 0xf1, 0xb5, 0x3d, 0x9a, 0x30, 0xe5, 0xc4, 0x5a, 0x56,
	0xec, 0x39, 0x67, 0x50, 0xc9, 0x37, 0x36, 0xa1, 0xc0, 0xd5, 0xc8, 0x3a, 0x2c, 0xe2, 0x4b, 0x63,
	0xe6, 0x46, 0x78, 0x73, 0x1e, 0xdd, 0x89, 0x8f, 0xf8, 0x74, 0x51, 0x68, 0x70, 0x7f, 0xe5, 0x9d,
	0xfc, 0xe9, 0x65, 0x75, 0x01, 0xb7, 0x87, 0x47, 0x5d, 0x3c, 0xb4, 0x3a, 0x6d, 0x4f, 0x17, 0xe9,
	0x54, 0x70, 0x09, 0x81, 0x82, 0x6b, 0x8f, 0x99, 0x0a, 0x95, 0xf8, 0x36, 0x7e, 0xd3, 0xa0, 0x7c,
	0xc0, 0xa2, 0x86, 0x87, 0x3e, 0x86, 0x94, 0xbd, 0x9a, 0x60, 0x06, 0x48, 0x15, 0x96, 0x03, 0xf9,
	0xd9, 0x17, 0xd7, 0x6a, 0xe2, 0xda, 0xdb, 0xd9, 0x6b, 0xcf, 0xeb, 0xc8, 0x77, 0x4a, 0x4a, 0x8d,
	0x1f, 0xc8, 0x17, 0x50, 0xc4, 0x43, 0x70, 0xa6, 0xdc, 0xbf, 0x9e, 0x55, 0x17, 0xba, 0xcf, 0x38,
	0x97, 0x4a, 0x21, 0xe3, 0x16, 0x14, 0x84, 0x56, 0x09, 0x16, 0x3b, 0xbd, 0x46, 0xc3, 0xa4, 0x2f,
	0xcb, 0x57, 0x08, 0xc0, 0x42, 0xd5, 0xea, 0x9a, 0xb5, 0x7a, 0x59, 0x33, 0x7e, 0x04, 0x48, 0xb5,
	0x12, 0x5f, 0xb4, 0xd4, 0x17, 0x8e, 0x29, 0xfe, 0x3f, 0xf4, 0xed, 0x81, 0x0c, 0x85, 0x4e, 0x53,
	0x02, 0x0f, 0xee, 0x6b, 0x16, 0x84, 0x08, 0x3e, 0x15, 0x80, 0xf8, 0x68, 0xec, 0xc1, 0x5a, 0xc6,
	0x9d, 0xd0, 0xf7, 0xdc, 0x90, 0x91, 0x2f, 0x61, 0x61, 0x2c, 0x28, 0x22, 0x15, 0xa5, 0xdd, 0x8f,
	0x2f, 0x98, 0x5f, 0xb5, 0x23, 0x9b, 0x2a, 0x21, 0xe3, 0x6f, 0x0d, 0xf4, 0x84, 0xfa, 0x7f, 0x5a,
	0xc7, 0xef, 0x42, 0xcc, 0xd9, 0x88, 0x64, 0x9e, 0x70, 0xf1, 0x4d, 0xbe, 0x03, 0x10, 0xef, 0xca,
	0xf4, 0x14, 0x45, 0x7a, 0x36, 0x66, 0x1a, 0x28, 0xf3, 0xa2, 0x0b, 0x69, 0xfe, 0x69, 0x3c, 0x51,
	0x71, 0xc6, 0xd0, 0x36, 0x5a, 0xd5, 0x5e, 0xdd, 0x92, 0x61, 0xde, 0xeb, 0x35, 0xab, 0xf8, 0xad,
	0x91, 0x32, 0x2c, 0x9b, 0xbd, 0x83, 0x86, 0xd5, 0xec, 0x9a, 0xdd, 0x5a, 0xab, 0x59, 0xce, 0x93,
	0x15, 0xd0, 0xab, 0xd6, 0xf3, 0x9a, 0x3c, 0x16, 0x8c, 0x7f, 0x34, 0x00, 0x0c, 0x57, 0x8c, 0x95,
	0xb4, 0x54, 0xb5, 0xb7, 0x94, 0x6a, 0x5c, 0x34, 0xb9, 0x39, 0x65, 0x26, 0x8b, 0xa6, 0xa2, 0xa0,
	0x9c, 0x17, 0x4e, 0x7d, 0x72, 0x0e, 0x73, 0x53, 0x68, 0x93, 0xa8, 0xbe, 0x0b, 0xab, 0x03, 0x7b,
	0x70, 0xca, 0xfa, 0x8e, 0x1b, 0xb1, 0x00, 0xeb, 0x41, 0x44, 0x2a, 0x4f, 0x57, 0x04, 0xb5, 0xa6,
	0x88, 0xc6, 0xb7, 0xca, 0xef, 0x45, 0xc8, 0x9b, 0xf5, 0xba, 0x74, 0x7a, 0xbf, 0xd5, 0x7c, 0x5a,
	0x3b, 0x40, 0xa7, 0x75, 0x28, 0x76, 0xd0, 0x5f, 0xab, 0x9c, 0x23, 0x57, 0xa1, 0xd4, 0x6a, 0x5b,
	0x54, 0x78, 0x6b, 0xd6, 0xcb, 0x79, 0xe3, 0x07, 0x28, 0x89, 0x87, 0x15, 0x2e, 0x1e, 0xc3, 0xb2,
	0x9b, 0x69, 0x64, 0x0a, 0x1d, 0xeb, 0x59, 0x3b, 0xb3, 0x8d, 0x8e, 0x4e, 0x49, 0x1b, 0x7f, 0x60,
	0xf0, 0x3a, 0x1f, 0x12, 0xbc, 0xb4, 0x4b, 0xe5, 0x2e, 0xef, 0x52, 0x58, 0x76, 0x8b, 0x01, 0xf3,
	0x47, 0x1c, 0x65, 0xf9, 0xb9, 0xcd, 0x2f, 0x16, 0x79, 0x9f, 0x4e, 0x69, 0x78, 0x50, 0xea, 0x64,
	0x22, 0xf1, 0xee, 0xc6, 0x7f, 0x03, 0x4b, 0x81, 0xd2, 0x52, 0xe6, 0x6f, 0xcc, 0x78, 0x46, 0x49,
	0xd0, 0x44, 0xd6, 0xf8, 0x57, 0x83, 0xd5, 0x69, 0xe6, 0x5b, 0xe6, 0x46, 0x0a, 0xb1, 0xcb, 0xfa,
	0xf2, 0xe7, 0xb0, 0x88, 0x0a, 0xa1, 0x3d, 0x94, 0x28, 0x3b, 0xd7, 0x99, 0xad, 0x20, 0xf0, 0x02,
	0x1a, 0x4b, 0x90, 0x87, 0x90, 0xf3, 0x7c, 0x01, 0xa9, 0xd5, 0xdd, 0x3b, 0xf3, 0xad, 0xde, 0x69,
	0xf9, 0x2c, 0x90, 0x19, 0x47, 0x79, 0x63, 0x1f, 0xf4, 0x84, 0x40, 0xd6, 0x60, 0xa5, 0xd9, 0xea,
	0xf6, 0x3b, 0x6d, 0x6b, 0xbf, 0xf6, 0xb4, 0x66, 0x55, 0xe3, 0xc6, 0x56, 0xb7, 0xba, 0xbc, 0xe2,
	0xb0, 0xe3, 0x51, 0xab, 0x5d, 0x37, 0xf7, 0x39, 0xfc, 0x90, 0xd1, 0x6b, 0x57, 0x39, 0x14, 0xf3,
	0x46, 0x1f, 0x8a, 0xc2, 0x18, 0xde, 0x02, 0x06, 0x58, 0xc0, 0xc2, 0xdf, 0x15, 0x2a, 0xbe, 0x79,
	0xc3, 0x88, 0x9d, 0x90, 0xcd, 0x24, 0xb1, 0x78, 0x5b, 0x35, 0x0c, 0xe9, 0xdb, 0xb5, 0x9d, 0xa1,
	0xe7, 0x0d, 0x47, 0x6c, 0x27, 0x1e, 0xd0, 0x3b, 0xa6, 0x7b, 0x26, 0xdb, 0x88, 0xf1, 0x4b, 0x0e,
	0xca, 0x9d, 0xc9, 0x51, 0x38, 0x08, 0x9c, 0x23, 0x16, 0x63, 0xf2, 0x31, 0xe8, 0x61, 0x4c, 0x53,
	0x99, 0xbd, 0x99, 0xf5, 0x5b, 0x29, 0xf8, 0xdc, 0xb5, 0xba, 0x13, 0x46, 0x87, 0x57, 0x68, 0xaa,
	0x40, 0x1e, 0x81, 0x7e, 0xca, 0xec, 0x20, 0x3a, 0x62, 0x76, 0xa4, 0xd2, 0x30, 0xd5, 0x39, 0x0f,
	0x63, 0x26, 0x57, 0x4b, 0x24, 0xb1, 0xdb, 0x16, 0x7c, 0x6f, 0x34, 0x52, 0x36, 0xdf, 0x98, 0x4a,
	0x1c, 0xd2, 0x95, 0x6d, 0xa8, 0x23, 0xc4, 0xc8, 0x57, 0xb0, 0x28, 0x06, 0x3d, 0x0b, 0x45, 0x66,
	0xce, 0xbd, 0x61, 0x72, 0x96, 0x32, 0x2d, 0x96, 0x23, 0x9f, 0x41, 0x11, 0x23, 0xf0, 0xe6, 0x4c,
	0x74, 0xcb, 0xd2, 0xee, 0x47, 0x53, 0x4f, 0x20, 0xc3, 0x61, 0x21, 0x95, 0x12, 0x7b, 0x3a, 0xaf,
	0x20, 0xf1, 0xa0, 0xf1, 0x6b, 0x1a, 0xa1, 0xc4, 0xe1, 0xf7, 0x00, 0x3e, 0x36, 0x8b, 0x30, 0xa3,
	0xad, 0xc0, 0xbf, 0x3e, 0x2f, 0x9c, 0x74, 0x4a, 0x9a, 0xdc, 0x82, 0xd2, 0x24, 0x64, 0xfd, 0xd8,
	0x53, 0x1e, 0x9b, 0x25, 0x0a, 0x48, 0x32, 0x95, 0x4f, 0xdb, 0x90, 0x7f, 0xe5, 0xc5, 0x21, 0x98,
	0x9a, 0xaf, 0xcf, 0x5a, 0x9d, 0x86, 0x1d, 0xfc, 0xe4, 0xb8, 0x43, 0xca, 0x45, 0x30, 0x2d, 0x05,
	0x3e, 0x02, 0xd4, 0xa8, 0xb8, 0x7d, 0x59, 0x3e, 0xc5, 0xec, 0xa0, 0x42, 0xdc, 0xd8, 0x82, 0x02,
	0x3f, 0x71, 0x54, 0x76, 0xba, 0xd4, 0x32, 0x1b, 0x08, 0xdd, 0x25, 0x28, 0xb4, 0x9a, 0xfb, 0x1c,
	0xb8, 0xf8, 0xd5, 0x6e, 0x61, 0x2f, 0xcd, 0xf1, 0x99, 0xb0, 0x9c, 0xbd, 0xe7, 0x1d, 0x17, 0xa4,
	0x07, 0xca, 0x2a, 0xb9, 0xb6, 0xcc, 0x45, 0x59, 0x6a, 0x10, 0xae, 0x54, 0x57, 0x43, 0x2c, 0xf4,
	0x51, 0xa6, 0xdb, 0xf3, 0xb0, 0x14, 0xe8, 0xaa, 0x24, 0xc7, 0xed, 0x1e, 0x01, 0x45, 0xc2, 0x89,
	0x8f, 0x69, 0x08, 0xc3, 0x7e, 0xc0, 0x8e, 0x27, 0xee, 0xb1, 0x8d, 0x5b, 0x55, 0x41, 0x84, 0x70,
	0x2d, 0xe6, 0xd0, 0x98, 0xc1, 0xc5, 0x13, 0x30, 0xa6, 0x57, 0x17, 0xc5, 0xd5, 0x6b, 0x09, 0x27,
	0x19, 0x26, 0x5b, 0x00, 0x69, 0x84, 0x45, 0x29, 0xca, 0x4f, 0x55, 0xa1, 0xf1, 0xd1, 0x78, 0x08,
	0x7a, 0x02, 0x46, 0xbe, 0x0e, 0xca, 0x55, 0x55, 0x8e, 0x8c, 0xb5, 0x0b, 0x90, 0x55, 0xdb, 0xab,
	0xd1, 0x83, 0xa2, 0x38, 0xbf, 0x63, 0x14, 0xb7, 0xe2, 0x7b, 0xe7, 0x75, 0x3d, 0x75, 0xed, 0x0a,
	0x94, 0x32, 0xb5, 0x64, 0x44, 0xb0, 0xa8, 0x70, 0xcf, 0x2d, 0x93, 0xb5, 0x31, 0xc3, 0x32, 0x2e,
	0x73, 0xa6, 0x2a, 0x83, 0x23, 0x32, 0xb2, 0x83, 0x21, 0x8b, 0xfa, 0x62, 0xbd, 0x91, 0x8d, 0x07,
	0x24, 0xa9, 0xc9, 0x97, 0x1c, 0x14, 0x18, 0x8c, 0x1c, 0xdc, 0x58, 0xfb, 0x99, 0x4d, 0x13, 0x24,
	0x89, 0x0b, 0x18, 0x8f, 0xa0, 0x28, 0x6e, 0xe4, 0x41, 0xb3, 0x8f, 0x8f, 0x79, 0x16, 0xd4, 0x96,
	0x14, 0x1f, 0x93, 0xe5, 0x29, 0x97, 0x59, 0x53, 0x7f, 0xd7, 0x60, 0x2d, 0xd3, 0xa9, 0xd4, 0x30,
	0xd8, 0x4d, 0x86, 0x97, 0x8c, 0xd0, 0xdc, 0x29, 0x8c, 0x8d, 0x20, 0x5e, 0xf7, 0x3f, 0xb0, 0x41,
	0xdd, 0x85, 0x95, 0xf0, 0xcc, 0x1d, 0xf4, 0x93, 0x39, 0x26, 0xaa, 0x11, 0x65, 0x96, 0x39, 0x39,
	0xb6, 0x68, 0x0f, 0xd2, 0x49, 0x67, 0xdc, 0x03, 0x3d, 0xb9, 0x8c, 0x6c, 0xc0, 0x52, 0x02, 0x2b,
	0x4d, 0xc0, 0x2a, 0x39, 0x1b, 0x7f, 0xe1, 0x52, 0xd0, 0xab, 0xb6, 0x5f, 0x04, 0xb6, 0x8f, 0x33,
	0x83, 0x6c, 0x42, 0xce, 0x39, 0x9e, 0x9b, 0x73, 0xe4, 0x71, 0xb4, 0x46, 0x81, 0xed, 0x86, 0x63,
	0x07, 0x17, 0xf4, 0x64, 0x1a, 0xe6, 0x24, 0x5a, 0x63, 0x4e, 0x37, 0x99, 0x8a, 0xbc, 0x68, 0x78,
	0xd2, 0xf1, 0x57, 0x5e, 0xdf, 0x9d, 0x8c, 0x8f, 0x58, 0x90, 0x14, 0x8d, 0x22, 0x37, 0x05, 0xf5,
	0xc2, 0x6e, 0x53, 0x78, 0x9f, 0xdd, 0xe6, 0xfe, 0x96, 0xda, 0xb0, 0xb0, 0x2d, 0x7c, 0xdf, 0xc1,
	0x55, 0xf1, 0x0a, 0x5f, 0xab, 0xf6, 0x5e, 0x76, 0xad, 0x8e, 0xdc, 0xb0, 0xda, 0xb4, 0xd5, 0x6d,
	0x95, 0x73, 0xf7, 0xcd, 0xe9, 0x96, 0x2a, 0x1a, 0x0c, 0x81, 0xd5, 0xae, 0x49, 0x0f, 0xac, 0x6e,
	0xbf, 0x6a, 0x3d, 0xad, 0x35, 0xc5, 0x8c, 0xc4, 0xbd, 0xb3, 0xd5, 0xec, 0xef, 0x1f, 0x9a, 0xcd,
	0x03, 0xde, 0x6d, 0x78, 0x0f, 0x32, 0x1b, 0x6d, 0x5c, 0x52, 0x73, 0xbb, 0x3f, 0xe7, 0x00, 0x70,
	0xbe, 0xba, 0xfb, 0xc2, 0x28, 0xdc, 0x2f, 0xf2, 0xb8, 0xa2, 0x91, 0xeb, 0xb3, 0x97, 0xc5, 0x8d,
	0x1b, 0x17, 0xe8, 0x0a, 0x3f, 0x87, 0xa0, 0x27, 0x8b, 0x3f, 0xb9, 0x79, 0xd9, 0xcf, 0x9b, 0x8d,
	0x4f, 0xe7, 0x70, 0xd5, 0x4d, 0x68, 0x41, 0xe7, 0xbc, 0x05, 0x9d, 0x39, 0x16, 0x64, 0x77, 0xa8,
	0x3a, 0xe8, 0x09, 0xac, 0xc9, 0xac, 0x06, 0x98, 0xcc, 0xe5, 0x69, 0x0b, 0x2e, 0xd4, 0xc2, 0xb6,
	0xf6, 0x40, 0x3b, 0x5a, 0x10, 0x33, 0xfe, 0xeb, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x24, 0xd1,
	0x4d, 0x2c, 0xec, 0x0f, 0x00, 0x00,
}
